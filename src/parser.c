// Last Change: 2025-03-27  Thursday: 08:54:23 PM
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include "parser.h"
#include "logging.h"

#define MAX_LINE_LENGTH 4096

// Snippet generated by Grok 3
// ----------------- Grok 3 snippet
char **remove_duplicates_and_sort(char **lines, size_t *count);

#ifdef  _WIN32
  static ssize_t getline(char **lineptr, size_t *n, FILE *stream);
  char *strdup(const char *s);
  char *strndup(const char *s, size_t n);
#endif
// Define replacements for POSIX functions if not available
#ifndef _WIN32
#include <unistd.h> // For getline on POSIX systems
#else
// Windows-specific getline implementation
static ssize_t getline(char **lineptr, size_t *n, FILE *stream) {
  if(lineptr == NULL || n == NULL || stream == NULL) {
    errno = EINVAL;
    return -1;
  }

  if(*lineptr == NULL || *n == 0) {
    *n = 128; // Initial buffer size
    *lineptr = (char *)malloc(*n);

    if(*lineptr == NULL) {
      errno = ENOMEM;
      return -1;
    }
  }

  size_t pos = 0;
  int c;

  while((c = fgetc(stream)) != EOF) {
    if(pos + 1 >= *n) {
      size_t new_size = *n * 2;
      char *new_ptr = (char *)realloc(*lineptr, new_size);

      if(new_ptr == NULL) {
        errno = ENOMEM;
        return -1;
      }

      *lineptr = new_ptr;
      *n = new_size;
    }

    (*lineptr)[pos++] = (char)c;

    if(c == '\n') {
      break;
    }
  }

  if(pos == 0 && c == EOF) {
    return -1;
  }

  (*lineptr)[pos] = '\0';
  return pos;
}
#endif

// Define strdup if not available (e.g., on MSVC)
#ifndef strdup
char *strdup(const char *s) {
  size_t len = strlen(s) + 1;
  char *d = (char *)malloc(len);

  if(d) {
    memcpy(d, s, len);
  }

  return d;
}
#endif

// Define strndup if not available
#ifndef strndup
char *strndup(const char *s, size_t n) {
  size_t len = strlen(s);

  if(len > n) {
    len = n;
  }

  char *d = (char *)malloc(len + 1);

  if(d) {
    memcpy(d, s, len);
    d[len] = '\0';
  }

  return d;
}
#endif

// Comparison function for qsort
static int compare_strings(const void *a, const void *b) {
  return strcmp(*(const char **)a, *(const char **)b);
}

// Function to remove duplicates and sort the array
char **remove_duplicates_and_sort(char **lines, size_t *count) {
  if(lines == NULL || count == NULL) {
    fprintf(stderr, "Error: Null pointer\n");
    exit(EXIT_FAILURE);
  }

  if(*count == 0) {
    return NULL;
  }

  // Sort the array first (makes duplicate removal easier)
  qsort(lines, *count, sizeof(char *), compare_strings);
  // Create a new array to hold unique strings
  char **unique_lines = malloc(*count * sizeof(char *));

  if(unique_lines == NULL) {
    fprintf(stderr, "Memory allocation failed\n");
    exit(EXIT_FAILURE);
  }

  // Copy the first string (it's always unique after sorting)
  unique_lines[0] = lines[0];
  size_t new_count = 1;

  // Process the rest of the strings
  for(size_t i = 1; i < *count; ++i) {
    if(strcmp(lines[i], unique_lines[new_count - 1]) != 0) {
      // If not a duplicate, add to unique_lines
      unique_lines[new_count] = lines[i];
      new_count++;
    }

    else {
      // If duplicate, free the string
      free(lines[i]);
    }
  }

  // Free the original lines array (but not its strings, as they're now in unique_lines or freed)
  free(lines);
  // Reallocate unique_lines to the exact size needed
  char **result = realloc(unique_lines, new_count * sizeof(char *));

  if(result == NULL && new_count > 0) {
    fprintf(stderr, "Memory reallocation failed\n");
    exit(EXIT_FAILURE);
  }

  // Update count
  *count = new_count;
  return result ? result : unique_lines;
}
// ----------------- Grok 3 snippet

int parse_project_file(const char *filename, char ***resources, size_t *count) {
  /*printf("DEBUG: fn parse_project_file, parser.c, received filename: %s\n", filename);*/
  FILE *file = fopen(filename, "r");

  if(!file) {
    perror("Failed to open project file");
    return 0;
  }

  *resources = NULL;
  *count = 0;
  char line[MAX_LINE_LENGTH];
  int inside_chain_or_producer = 0; // Tracks whether we're inside <chain> or <producer>

  while(fgets(line, sizeof(line), file)) {
    // Check for the start of a <chain> or <producer>
    if(strstr(line, "<chain id=") || strstr(line, "<producer id=")) {
      inside_chain_or_producer = 1;
    }

    else if(inside_chain_or_producer && (strstr(line, "</chain>") || strstr(line, "</producer>"))) {
      inside_chain_or_producer = 0;
    }

    // Extract resource paths within <chain> or <producer>
    if(inside_chain_or_producer && strstr(line, "<property name=\"resource\">")) {
      char *start = strchr(line, '>') + 1;
      char *end = strrchr(line, '<');

      if(start && end) {
        size_t len = end - start;
        char *resource = malloc(len + 1);

        if(!resource) {
          fclose(file);
          free_strings_array(*resources, *count);
          return 0;
        }

        strncpy(resource, start, len);
        resource[len] = '\0';
        // Add to resources array
        *resources = realloc(*resources, (*count + 1) * sizeof(char *));

        if(!*resources) {
          fclose(file);
          free_strings_array(*resources, *count);
          free(resource);
          return 0;
        }

        (*resources)[*count] = resource;
        (*count)++;
      }
    }
  }

  fclose(file);
  // Remove duplicates and sort the resources
  *resources = remove_duplicates_and_sort(*resources, count);
  /*printf("DEBUG: fn parse_project_file, parser.c, Total unique resources parsed: %ld\n", *count);*/
  return 1;
}

void free_strings_array(char **array, size_t count) {
  if(!array) {
    return;
  }

  for(size_t i = 0; i < count; ++i) {
    free(array[i]);
  }

  free(array);
}
